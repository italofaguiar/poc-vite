# Respondendo as Dúvidas - Sessão 2

Data: 16/11/2025

---

## 1. Estrutura da aplicação: qual a melhor abordagem?

**Opções:**
- a) backend ("bff" + api) em python em 1 CloudRun só e frontend em Vite
- b) api em python em CRun privado, e outro CRun (publico) com Nextjs fazendo BFF (pra cuidar de auth (google oauth2, email/senha etc)) bem cm o frontend.

### Resposta: Opção A (Backend Python BFF+API único + Frontend Vite)

**Justificativa:**

#### 1. Alinhamento com o contexto
- **Timing**: 2 meses para MVP → menos complexidade = entrega mais rápida
- **Expertise**: Domínio alto em Python, básico em Node/TS/React
- **Equipe**: 1 dev agora, +1 fullstack jr em 3 meses
- **KISS**: Princípio fundamental do projeto

#### 2. Vantagens técnicas

**Simplicidade arquitetural:**
- 1 backend (vs 2 backends na opção B)
- 1 ORM - SQLAlchemy (vs 2: SQLAlchemy + Prisma)
- Menos deploys e configurações
- Menos moving parts = menos pontos de falha

**Segurança mais direta:**
- Defense in depth natural: cada rota valida JWT independentemente
- 1 trust boundary clara: Frontend → Backend
- Mais fácil de auditar e testar
- Não depende de "API confiar cegamente no BFF"

**Aproveitamento do conhecimento existente:**
- FastAPI já está rodando em produção
- Toda lógica de negócio (LLM, RAG, WhatsApp, CRM) já está em Python
- Auth em FastAPI é padrão de mercado (OAuth2, JWT, cookies HttpOnly)

**Infra mais simples:**
- 1 Cloud Run (backend) + Cloud Storage/CDN (frontend Vite)
- Não precisa de VPC Connector (~$50/mês)
- Não precisa de service-to-service authentication
- Deploy independente: frontend e backend

#### 3. Trade-offs da Opção B (NextJS BFF)

**Única vantagem real:**
- NextAuth.js facilita implementação inicial de OAuth2 (~1-2 semanas de ganho)

**Desvantagens:**
- Curva de aprendizado: Next.js patterns + Prisma + NextAuth
- 2 backends para manter e deployar
- 2 ORMs mexendo no mesmo banco (sincronização de schema)
- Complexidade de service-to-service auth (VPC + secrets ou service accounts)
- Mais complexo de debugar (mais camadas)

**Conclusão**: Ganho de 1-2 semanas não compensa a complexidade permanente.

#### 4. Quando reconsiderar NextJS BFF?

Apenas se no futuro você tiver:
- Time de 5+ devs com especialização (frontend vs backend)
- Múltiplos frontends (web + mobile) precisando do mesmo BFF
- Necessidade real de SSR/Edge computing
- Compliance rigoroso exigindo API 100% privada (PCI-DSS, HIPAA)

**Nenhum desses cenários se aplica agora ou no médio prazo.**

---

## Arquitetura Recomendada (Opção A)

```
┌─────────────────────────────────────┐
│ Frontend Vite (app.pilotodevendas)  │
│ - React + TypeScript                │
│ - TanStack Query (cache)            │
│ - Zustand (estado)                  │
│ - Tailwind + shadcn/ui              │
└──────────────┬──────────────────────┘
               │ HTTPS + CORS
               │ JWT em HttpOnly cookies
               ▼
┌─────────────────────────────────────┐
│ Backend Python (api.pilotodevendas) │
│                                     │
│ ┌─────────────────────────────────┐ │
│ │ BFF Layer (rotas /api/v1/*)     │ │
│ │ - Auth (OAuth2 Google)          │ │
│ │ - Auth (email/senha)            │ │
│ │ - JWT + refresh tokens          │ │
│ │ - CORS config                   │ │
│ │ - Rate limiting                 │ │
│ └─────────────────────────────────┘ │
│                                     │
│ ┌─────────────────────────────────┐ │
│ │ API Layer                       │ │
│ │ - LLM, RAG, WhatsApp            │ │
│ │ - CRM integrations              │ │
│ │ - Business logic                │ │
│ │ - Dashboards, configs           │ │
│ └─────────────────────────────────┘ │
│                                     │
│ FastAPI + SQLAlchemy                │
└──────────────┬──────────────────────┘
               │
               ▼
         [Postgres DB]
      (CloudSQL no GCP)
```

### Stack Tecnológica

**Frontend (Vite):**
- Vite + React + TypeScript
- TanStack Query (react-query) para cache e sincronização
- Zustand ou Context API para estado global
- TailwindCSS + shadcn/ui (componentes prontos)
- Axios ou Fetch API com credentials: 'include'

**Backend (FastAPI - já existente + adições):**
- authlib ou httpx-oauth (Google OAuth2)
- python-jose (JWT)
- passlib + bcrypt (hash de senhas)
- slowapi (rate limiting)
- CORS middleware configurado

**Infra:**
- Backend: Cloud Run (já existe)
- Frontend: Cloud Storage + Cloud CDN
- Banco: Postgres CloudSQL (já existe)

### Fluxo de Autenticação

**1. Email/Senha:**
```
POST /api/v1/auth/signup
- Backend valida email, hash senha (bcrypt)
- Cria user no banco
- Gera JWT access token (15min) + refresh token (7 dias)
- Retorna tokens em HttpOnly cookies
- Frontend redireciona para /dashboard

POST /api/v1/auth/login
- Backend valida credenciais
- Gera tokens, seta cookies
- Retorna user info
```

**2. Google OAuth2:**
```
GET /api/v1/auth/google/login
- Backend redireciona para Google OAuth2

GET /api/v1/auth/google/callback?code=...
- Backend troca code por access token
- Pega user info do Google
- Cria/atualiza user no banco (tabela user_identities)
- Gera JWT tokens
- Seta cookies HttpOnly
- Redireciona para /dashboard
```

**3. Requests subsequentes:**
```
Frontend faz request com { credentials: 'include' }
→ Cookies enviados automaticamente
→ Backend valida JWT via dependency
→ Se expirado, refresh automático
→ Se refresh expirado, redireciona para login
```

### Segurança

**Proteção de rotas:**
```python
from fastapi import Depends

async def get_current_user(token: str = Depends(oauth2_scheme)):
    # Valida JWT, retorna user
    payload = jwt.decode(token, SECRET_KEY)
    user = await db.get_user(payload["user_id"])
    if not user:
        raise HTTPException(401)
    return user

# Rota protegida
@app.get("/api/v1/agents")
async def list_agents(user: User = Depends(get_current_user)):
    return await db.get_agents(user.id)
```

**CORS:**
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://app.pilotodevendas.com.br"],
    allow_credentials=True,  # Necessário para cookies
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**Outras proteções:**
- Rate limiting (slowapi) nas rotas de auth
- CSRF tokens em mutations (POST/PUT/DELETE)
- Tokens de curta duração (15min access, 7 dias refresh)
- HttpOnly + Secure + SameSite cookies

### Infra e Domínios

**Opção recomendada (mais simples):**
```
api.pilotodevendas.com.br → Cloud Run (FastAPI)
app.pilotodevendas.com.br → Cloud Storage + CDN (Vite build)

CORS configurado no FastAPI para aceitar app.pilotodevendas.com.br
```

**Alternativa (mesmo domínio, requer Load Balancer):**
```
app.pilotodevendas.com.br
├── /* → Cloud Storage (Vite)
└── /api/* → Cloud Run (FastAPI)

Via Cloud Load Balancer com path-based routing
```

**Recomendação:** Começar com domínios separados (mais simples). Migrar depois se necessário.

---

## Robustez da Solução

### É arquitetura de mercado
Empresas usando FastAPI como BFF+API + SPA separado:
- Uber (partes do sistema)
- Netflix (microservices internos)
- Microsoft (Azure ML)
- Explosion.ai (Spacy)

### Camadas de segurança
1. CORS (só aceita frontend oficial)
2. JWT validation em cada rota protegida
3. Rate limiting
4. HttpOnly cookies (proteção XSS)
5. CSRF tokens
6. Tokens de curta duração

### Escalabilidade
- Cloud Run escala horizontal automaticamente
- FastAPI async = performance comparable a Node
- Frontend estático no CDN = infinitamente escalável
- Gargalo real: Postgres (mas isso é independente da escolha de stack)

### Manutenibilidade
- Deploy independente (frontend vs backend)
- Código em Python (que você domina)
- Menos moving parts
- Mais fácil de debugar

---

## Próximos Passos

1. Setup inicial do Vite + estrutura de pastas
2. Implementar auth no FastAPI (email/senha + Google OAuth2)
3. Configurar CORS + cookies HttpOnly
4. Criar endpoints de BFF necessários
5. Setup de deploy (Cloud Storage + CDN)

**Tempo estimado:** Viável em 2 meses com folga.

---

## Decisão Final

**✅ Backend Python (BFF+API) + Frontend Vite**

Arquitetura robusta, alinhada com KISS, aproveita expertise existente, e perfeitamente adequada para o contexto e prazo do projeto.
