# JWT vs Session ID - Análise e Recomendação

**Data:** 16/11/2025
**Contexto:** Backend Python + FastAPI, Frontend React, MVP em 2 meses

---

## a) JWT puro stateless ou Session ID? Ou híbrido?

### Recomendação: **Session ID** (stateful)

**Justificativa:**

Dado seu contexto específico, Session ID é a escolha mais adequada:

1. **Você já tem Postgres rodando** (CloudSQL) → não adiciona complexidade de infra
2. **Revogação imediata** → essencial para logout, ban de usuários, ou segurança
3. **Payload pequeno** → cookies menores, menos overhead em cada request
4. **Menos complexidade** → não precisa gerenciar refresh tokens, rotação de secrets, claims validation
5. **Melhor para MVP** → implementação mais direta e robusta

### Por que NÃO JWT stateless puro?

JWT stateless puro traz problemas no seu caso:

- **Não tem revogação imediata** → se precisar invalidar (logout, ban, mudança de permissões), você vai precisar de blacklist/whitelist em Redis/DB
- **Se adicionar blacklist, perdeu a vantagem** → virou stateful mesmo, mas mais complexo
- **Tokens maiores** → especialmente se adicionar claims (permissions, metadata)
- **Rotação de secrets mais trabalhosa** → precisa gerenciar múltiplos secrets simultaneamente

### Sobre o Cookie HttpOnly

**SIM**, independente da escolha, use **HttpOnly + Secure + SameSite=Lax (ou Strict)**:

```
Set-Cookie: session_id=abc123; HttpOnly; Secure; SameSite=Lax; Max-Age=604800
```

- **HttpOnly** → JavaScript não acessa → mitiga XSS
- **Secure** → só envia em HTTPS
- **SameSite** → mitiga CSRF

---

## b) Se stateless precisar de blacklist/Redis, não seria melhor Session ID logo?

### Resposta: **EXATAMENTE!**

Você captou perfeitamente o ponto. Se você precisa de:

- Logout funcional
- Revogar acesso de usuários
- Invalidar sessões comprometidas
- Controlar sessões ativas (ex: limitar a 1 dispositivo)

Então JWT stateless **obrigatoriamente** precisa de:
- Blacklist de tokens (Redis/DB)
- Ou whitelist de tokens válidos
- Ou short-lived tokens + refresh tokens (que precisa de DB)

**Nesse momento você perdeu a única vantagem do JWT stateless** (não ter estado no servidor).

**Conclusão:** Para 99% dos casos como o seu → Session ID é mais simples e robusto.

---

## c) Refresh tokens ou refresh process?

### Com Session ID: **Não precisa de refresh token**

Session ID já é stateful, então:

1. **Sessão de longa duração** (ex: 7 dias) com renovação deslizante:
   - A cada request, se faltam < 50% do tempo, renova automaticamente
   - Usuário fica logado enquanto usar a app
   - Se ficar inativo por 7 dias, expira

2. **Implementação simples:**

```python
# FastAPI middleware (pseudocódigo)
async def renew_session_if_needed(session_id: str):
    session = await db.get_session(session_id)

    time_remaining = session.expires_at - now()
    total_duration = timedelta(days=7)

    # Se faltam menos de 50% do tempo, renova
    if time_remaining < total_duration * 0.5:
        session.expires_at = now() + total_duration
        await db.save(session)
```

### Se fosse JWT (não é sua escolha, mas para conhecimento)

Precisaria de **refresh tokens**:

- **Access token** curto (15 min)
- **Refresh token** longo (7 dias) armazenado no DB
- Frontend detecta 401 → usa refresh token → pega novo access token
- Mais complexidade no backend e frontend

---

## d) Se tiver Postgres/Redis no auth, quem é o dono?

### Com Session ID (sua escolha recomendada)

**Backend Python é o dono de tudo:**

1. **Schema/ORM:** SQLAlchemy define e gerencia
   ```python
   # models/session.py
   class Session(Base):
       __tablename__ = "sessions"

       id = Column(String, primary_key=True)  # UUID
       user_id = Column(Integer, ForeignKey("users.id"))
       created_at = Column(DateTime, default=now)
       expires_at = Column(DateTime)
       ip_address = Column(String)
       user_agent = Column(String)
   ```

2. **Quem lê/escreve:**
   - **Backend Python** lê e escreve
   - Se tiver BFF (NextJS), ele **só passa o cookie** para o backend Python
   - Python valida a session e retorna os dados do usuário

3. **Redis (opcional, para performance):**
   - Postgres: source of truth (sessions persistem aqui)
   - Redis: cache de sessions (TTL automático)
   - Leitura: tenta Redis → fallback Postgres
   - Escrita: escreve em ambos

### Fluxo recomendado

```
┌─────────┐         ┌──────────┐         ┌──────────┐         ┌──────────┐
│ Browser │────────>│   BFF    │────────>│  Python  │────────>│ Postgres │
│         │ cookie  │ (NextJS  │ cookie  │  FastAPI │  R/W    │          │
│         │<────────│optional) │<────────│          │<────────│          │
└─────────┘         └──────────┘         └──────────┘         └──────────┘
                                                │                    ^
                                                │       ┌──────────┐ │
                                                └──────>│  Redis   │─┘
                                                 cache  │ (cache)  │
                                                        └──────────┘
```

**Importante:** Se tiver BFF (NextJS):
- BFF **NÃO** toca no banco de sessions
- BFF **NÃO** valida sessions
- BFF só **encaminha o cookie** para o Python
- Python é o único que valida e gerencia sessions

---

## Recomendação Final: Stack de Auth

### Setup Proposto

**Backend Python (FastAPI):**
- Sessions em Postgres (SQLAlchemy)
- Redis para cache (opcional, mas recomendado)
- HttpOnly cookies com session_id
- Endpoints:
  - `POST /auth/login` → cria session, retorna cookie
  - `POST /auth/logout` → deleta session
  - `GET /auth/me` → retorna user da session
  - `POST /auth/google` → OAuth2 Google

**Frontend (Vite ou NextJS):**
- Apenas **envia o cookie automaticamente** em cada request
- Não armazena nem manipula tokens
- Não acessa o cookie via JavaScript

**Libs sugeridas:**
- `fastapi-sessions` ou implementação custom (é simples)
- Para OAuth2: `authlib` (Python)

### Exemplo de código

```python
# auth/service.py
from uuid import uuid4
from datetime import datetime, timedelta

async def create_session(user_id: int, request: Request) -> str:
    session_id = str(uuid4())

    session = Session(
        id=session_id,
        user_id=user_id,
        expires_at=datetime.utcnow() + timedelta(days=7),
        ip_address=request.client.host,
        user_agent=request.headers.get("user-agent")
    )

    # Salva no DB
    db.add(session)
    await db.commit()

    # Cache no Redis (opcional)
    await redis.setex(f"session:{session_id}", 604800, user_id)

    return session_id

async def get_user_from_session(session_id: str) -> User | None:
    # Tenta cache primeiro
    user_id = await redis.get(f"session:{session_id}")

    if not user_id:
        # Fallback para DB
        session = await db.query(Session).filter_by(id=session_id).first()
        if not session or session.expires_at < datetime.utcnow():
            return None
        user_id = session.user_id

    user = await db.query(User).filter_by(id=user_id).first()
    return user
```

```python
# main.py (FastAPI)
@app.post("/auth/login")
async def login(credentials: LoginRequest, response: Response):
    user = await authenticate(credentials.email, credentials.password)
    if not user:
        raise HTTPException(401, "Invalid credentials")

    session_id = await create_session(user.id, request)

    response.set_cookie(
        key="session_id",
        value=session_id,
        httponly=True,
        secure=True,  # HTTPS only
        samesite="lax",
        max_age=604800  # 7 dias
    )

    return {"user": user.dict()}

@app.get("/auth/me")
async def me(session_id: str = Cookie(None)):
    if not session_id:
        raise HTTPException(401, "Not authenticated")

    user = await get_user_from_session(session_id)
    if not user:
        raise HTTPException(401, "Invalid session")

    return {"user": user.dict()}
```

---

## Vantagens da abordagem Session ID no seu contexto

1. ✅ **Simples** → MVP em 2 meses, KISS
2. ✅ **Seguro** → revogação imediata, controle total
3. ✅ **Aproveitamento da stack** → Postgres já existe
4. ✅ **Experiência da equipe** → Python (alta) gerencia tudo
5. ✅ **Escalável o suficiente** → Redis cache resolve performance
6. ✅ **Menos código no frontend** → cookie automático
7. ✅ **Debugging mais fácil** → sessions no DB, visíveis e manipuláveis

---

## Quando considerar JWT?

JWT stateless faz sentido em cenários que **NÃO** são o seu:

- Microserviços distribuídos (cada serviço valida sem DB)
- APIs públicas stateless (ex: GitHub API)
- Cross-domain auth complexo
- Sistemas onde revogação imediata não é crítica

**No seu caso:** você tem 1 backend monolítico (Python), 1 DB (Postgres), e precisa de revogação. Session ID é a escolha natural.

---

## Resumo Executivo

| Aspecto | Recomendação |
|---------|--------------|
| **Abordagem** | Session ID (stateful) |
| **Storage** | Postgres (source of truth) + Redis (cache) |
| **Cookie** | HttpOnly, Secure, SameSite=Lax |
| **Duração** | 7 dias com renovação deslizante |
| **Refresh tokens** | Não precisa |
| **Quem gerencia** | Backend Python (SQLAlchemy) |
| **BFF (se tiver)** | Só encaminha cookie, não valida |

**Bottom line:** Para o seu contexto (MVP, KISS, Python backend, 1 dev), Session ID é mais simples, seguro e adequado que JWT stateless.
