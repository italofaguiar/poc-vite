# Dúvida 2 — JWT vs Session ID

_Data: 17/11/2025_

## TL;DR
- Prefira sessões opacas salvas no backend (Redis com TTL + espelho em Postgres) e expostas via cookie `HttpOnly; Secure; SameSite=None`. A mesma sessão atende login interno e Google OAuth e facilita revogação.
- JWT assinado só entra quando um serviço externo precisa provar identidade sem consultar o seu store de sessão. Mantém o FastAPI como autoridade e evita múltiplas fontes de verdade.
- O backend Python continua dono do schema (`users`, `sessions`, `user_identities`). Qualquer outro componente cria ou invalida sessão falando com a API, nunca mexendo direto no banco.

## Detalhamento
### a) Stateless JWT ou Session ID?
- Seu backend já é stateful (Postgres, Redis, filas) e aplica autorização específica por usuário. Sessão opaca + lookup rápido em Redis mantém o KISS e dá revogação imediata.
- JWT puro faz sentido quando vários serviços independentes não conseguem consultar um storage comum. Hoje tudo passa pelo FastAPI, então JWT só adicionaria rotação, validação em múltiplos lugares e risco de vazamento sem benefício real.

### b) “Se preciso de Redis/DB para blacklist, não é melhor sessão?”
- Exato. O momento em que você cria qualquer lista server-side (blacklist, device binding, MFA step-up) já elimina o ganho do stateless. Use `session_id` opaco e deixe Redis como verdade da sessão.

### c) Refresh tokens ou sessão deslizante?
- Para o dashboard web: sessão com expiração curta (ex.: 12 horas) + renovação deslizante. Cada request autenticada renova o TTL em Redis e reescreve o cookie com `Max-Age` novo.
- Refresh tokens ficam para cenários mobile/offline ou quando você precisa emitir um JWT específico (por exemplo, para integrar com um serviço externo). Guarde apenas o hash do refresh no banco para revogar dispositivo por dispositivo.

### d) Quem cuida de Postgres/Redis no auth?
- FastAPI mantém migrations SQLAlchemy para `users`, `user_identities` e `sessions`. Mesmo que um futuro BFF em NextJS apareça, ele chama endpoints REST/GraphQL para criar usuários e sessões.
- Leitura quente acontece em Redis. Postgres é usado para auditoria, relatórios e restauração completa após restart. O BFF nunca enxerga o banco diretamente.

## Passos Práticos
1. Criar tabela `sessions` (ou hash Redis) com `session_id`, `user_id`, `scopes`, `expires_at` e `metadata` (IP, user-agent).
2. Login (email/senha ou Google): FastAPI valida credenciais, persiste sessão, retorna cookie `session_id` HttpOnly e entrega um token CSRF separado para formulários mutáveis.
3. Middleware FastAPI lê o cookie, busca sessão no Redis e aplica sliding window. Se a sessão estiver perto do vencimento, renove TTL e reescreva o cookie.
4. Para WebSockets ou workers: endpoint `/session/token` gera um JWT curto (5 minutos) baseado na sessão já autenticada; o frontend usa esse token no header do socket. Ao revogar a sessão, você simplesmente para de emitir tokens novos.
5. Logout manual remove a chave em Redis e seta o cookie com `Max-Age=0`. Logout global de segurança remove todas as sessões daquele `user_id`.

Esse desenho funciona bem no combo Cloud Run + FastAPI + Vite, mantém simplicidade para o MVP e ainda abre espaço para JWTs específicos quando realmente precisar conversar com outros serviços.
